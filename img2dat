#!/usr/bin/env python

import os, sys

from PIL import Image
import argparse


LS_SCREEN_W = 128
LS_SCREEN_H = 64

SCALEFACTOR = 4

PAGES = 8
ADDRESSES = 128
PIXELS_PER_ADDRESS = 8
BITS_PER_PIXEL = 2

BITS_PER_BLOCK = 8


DEFAULT_FRAME=(8,8)

TRANSPARENT_COLOR = (255,0,255)

TILESIZE = 8


# Basic functions
def tupleMultiply(scalar,tup):
    return tuple([scalar*x for x in tup])

def ceilMultiple(x, multiple):
    if x % multiple == 0:
        return x
    else:
        return ((x/multiple)+1)*multiple

def getCommandLineArguments():
    parser = argparse.ArgumentParser(description='Convert images to Propeller Spin data blocks for use with Lame Graphics.')

    parser.add_argument('-m','--mode', nargs=1, metavar=('MODE'), choices=['box','sprite','font','tilemap'], default=['sprite'],
            help="""Indicates what the image is to be converted into:
                box - An image with a fixed 8x8 size, compatible with the box command.
                tilemap - A collection of boxes chopped from a tilemap image.
                sprite - An image of any width and height that may have multiple frames.
                font - Parse the image as a bitmap font.
            """)
    parser.add_argument('-b','--bits', nargs=1, metavar=('BITS'), type=int, choices=[2,8],default=[2],
            help="Bit depth of images.")
    parser.add_argument('-f','--framesize', nargs=2, metavar=('WIDTH','HEIGHT'), type=int,
            help="Size of individual sprite frames (only needed for sprites).")
    parser.add_argument('-d','--display', action='store_true',
            help="Show graphic comparison of old and new images.")

    parser.add_argument('filenames', metavar='FILE', nargs='+', help='Files to convert')
    return parser.parse_args()

def printImageTag():
    print "'   Creating:",newfilename
    print "'  Bit depth:", args.bits[0]
    print "' Image Type:", args.mode[0]
    print "' Image size:",im.size
    print "' Frame size:",framesize
    print "'     Frames:",im.size[1]/framesize[1],",",im.size[0]/framesize[0]


def cleanFilenames(filenames):
    filenames = [ i for i in filenames if not os.path.splitext(i)[1] == '.dat' and os.path.isfile(i) ]
    filenames = [ i for i in filenames if not os.path.splitext(i)[1] == '.txt' ]
    return filenames


def openImage(filename):
    try:
        im = Image.open(filename)
    except IOError:
        print filename, "is not a valid image file"
        sys.exit(1)
    
    return im.convert("RGB")

def getAverageColor(pixel):
    if type(pixel) is tuple:
        return sum(pixel)/3
    else:
        return pixel


def displayConversionResults(input_image, output_image):
    canvas = Image.new("RGB",(input_image.size[0],input_image.size[1]*2))

    canvas.paste(input_image,(0,0))
    canvas.paste(output_image,(0,input_image.size[1]))
    
    canvas = canvas.resize(tupleMultiply(SCALEFACTOR,(im.size[0],im.size[1]*2)))
    canvas.show()


def printConversionResults(filename):
    print
    print open(filename,'r').read()



def requirePower3FrameSize(framesize):
    if not framesize[0] % 8 == 0:
        print "Error:",args.mode[0],"frame size x must be multiple of 8. Aborting."
        sys.exit(1)
    
    if not framesize[1] %8 == 0:
        print "Error:",args.mode[0],"frame size y must be multiple of 8. Aborting."
        sys.exit(1)


def padFrameSize(framesize, size):
    return tuple([ceilMultiple(framesize[0], size),ceilMultiple(framesize[1], size)])


def getFrameSize(framesize, image):
    if framesize:
        framesize = tuple(framesize)
        if not framesize < image.size:
            print "Frame is larger than image; exiting"
            sys.exit(1)
        return framesize
    else:
        return image.size



args = getCommandLineArguments()
filenames = cleanFilenames(args.filenames)


if not filenames:
    print "No valid files selected"
else:
    for filename in filenames:


        im = openImage(filename)
        output_im = Image.new("RGB",im.size)

        newfilename = filename+".dat"
        output_txt = open(newfilename,'w')
        output_txt.write("gfx_%s\n" % os.path.splitext(os.path.basename(filename))[0])


        if args.mode[0] == 'sprite':

            framesize = getFrameSize(args.framesize, im)

            # Calculate frameboost constant, the precalculated frame size so 
            # that jumping to a frame requires only one multiplication, not three.
            frameboost = (framesize[0]*BITS_PER_PIXEL*framesize[1]/PIXELS_PER_ADDRESS) & 0xFFFF
            dimensions = (framesize[0] & 0xFFFF , framesize[1] & 0xFFFF) 

            output_txt.write("word    %i" % frameboost + "  'frameboost\n")
            output_txt.write("word    %i, %i   'width, height\n" % dimensions )

        elif args.mode[0] == 'box':
            framesize = im.size

        elif args.mode[0] == 'tilemap':
            framesize = DEFAULT_FRAME


        if args.mode[0] == 'font':
            output_framesize = DEFAULT_FRAME
        else:
            output_framesize = framesize



        if args.bits[0] == 2:
            if args.mode[0] == 'font':
                padFrameSize(framesize, 8)
            else:
                requirePower3FrameSize(framesize)

        wordcount = 0
        colordata = 0

        for frame_y in range(0,im.size[1]/framesize[1]):
            for frame_x in range(0,im.size[0]/framesize[0]):

                for py in range(0,framesize[1]):
                    for px in range(0,framesize[0]):

                        x = frame_x*framesize[0] + px
                        y = frame_y*framesize[1] + py

                        if x % BITS_PER_BLOCK == 0:
                            colordata = 0

                        colorchar = 0
                        pixeldata = im.getpixel((x,y))

                        if args.bits[0] == 2:

                            coloravg = getAverageColor(pixeldata)

                            # Pink is the alpha color
                            if pixeldata == TRANSPARENT_COLOR:
                                output_im.putpixel((x,y), TRANSPARENT_COLOR)
                                colorchar = 2

                            elif coloravg < 40: # black
                                output_im.putpixel((x,y), (23,43,66))
                                colorchar = 0

                            elif 40 < coloravg < 210: # gray
                                output_im.putpixel((x,y), (139, 138, 116))
                                colorchar = 3

                            elif coloravg > 210: # white
                                output_im.putpixel((x,y), (255, 233, 166))
                                colorchar = 1

                            colordata += (colorchar << ((x % BITS_PER_BLOCK)*2))


                            if x % BITS_PER_BLOCK == BITS_PER_BLOCK-1 or x == im.size[0]-1:
                                output_txt.write("$"+hex(colordata)[2:].zfill(BITS_PER_BLOCK/2))

                            if x % BITS_PER_BLOCK == 0:
                                if wordcount % (BITS_PER_BLOCK*2) == 0:
                                    output_txt.write("\nword    ")
                                else:
                                    if x < im.size[0]-1:
                                        output_txt.write(", ")

                                wordcount += 1



                        elif args.bits[0] == 8:
                            if type(pixeldata) is tuple:
                                r = pixeldata[0] >> 6 << 6
                                g = pixeldata[1] >> 6 << 6
                                b = pixeldata[2] >> 6 << 6
                                output_im.putpixel((x,y), (r, g, b))
                                colorchar = (r) + (g >> 2) + (b >> 4)
                            else:
                                print "Color data not in tuple format?"
                                sys.exit(1)

        output_txt.close()

        if args.display:
            displayConversionResults(im, output_im)

        printImageTag()
        printConversionResults(newfilename)
