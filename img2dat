#!/usr/bin/env python

import os, sys

from PIL import Image
import argparse


# white on black
#BLACK=(0,30,40)
#GRAY=(80,110,130)
#WHITE=(210,255,255)

BLACK=(145,64,254)
GRAY=(177,125,225)
WHITE=(204,206,203)

LS_SCREEN_W = 128
LS_SCREEN_H = 64

SCALEFACTOR = 4

PAGES = 8
ADDRESSES = 128
PIXELS_PER_ADDRESS = 8
BITS_PER_PIXEL = 2

BITS_PER_BLOCK = 8


DEFAULT_FRAME=(8,8)

TRANSPARENT_COLOR = (255,0,255)

TILESIZE = 8


# Basic functions
def tupleMultiply(scalar,tup):
    return tuple([scalar*x for x in tup])

def ceilMultiple(x, multiple):
    if x % multiple == 0:
        return x
    else:
        return ((x/multiple)+1)*multiple

def getCommandLineArguments():
    parser = argparse.ArgumentParser(description='Convert images to Propeller Spin data blocks for use with Lame Graphics.')

    parser.add_argument('-m','--mode', nargs=1, metavar=('MODE'), choices=['box','sprite','font','tilemap'], default=['sprite'],
            help="""Indicates what the image is to be converted into:
                box - An image with a fixed 8x8 size, compatible with the box command.
                tilemap - A collection of boxes chopped from a tilemap image.
                sprite - An image of any width and height that may have multiple frames.
                font - Parse the image as a bitmap font.
            """)
    parser.add_argument('-b','--bits', nargs=1, metavar=('BITS'), type=int, choices=[2,8],default=[2],
            help="Bit depth of images.")
    parser.add_argument('-f','--framesize', nargs=2, metavar=('WIDTH','HEIGHT'), type=int,
            help="Size of individual sprite frames (only needed for sprites).")
    parser.add_argument('-d','--display', action='store_true',
            help="Show graphic comparison of old and new images.")

    parser.add_argument('filenames', metavar='FILE', nargs='+', help='Files to convert')
    return parser.parse_args()

def printImageTag():
    print "'   Creating:",newfilename
    print "'  Bit depth:", args.bits[0]
    print "' Image Type:", args.mode[0]
    print "' Image size:",im.size
    print "' Frame size:",framesize
    print "'     Frames:",count_tiles_x,",",count_tiles_x


def cleanFilenames(filenames):
    filenames = [ i for i in filenames if not os.path.splitext(i)[1] == '.dat' and os.path.isfile(i) ]
    filenames = [ i for i in filenames if not os.path.splitext(i)[1] == '.txt' ]
    return filenames


def openImage(filename):
    try:
        im = Image.open(filename)
    except IOError:
        print filename, "is not a valid image file"
        sys.exit(1)
    
    return im.convert("RGB")

def getAverageColor(pixel):
    if type(pixel) is tuple:
        return sum(pixel)/3
    else:
        return pixel


def printConversionResults(filename):
    print
    print open(filename,'r').read()



def requirePower3FrameSize(framesize):
    if not framesize[0] % 8 == 0:
        print "Error:",args.mode[0],"frame size x must be multiple of 8. Aborting."
        sys.exit(1)
    
    if not framesize[1] %8 == 0:
        print "Error:",args.mode[0],"frame size y must be multiple of 8. Aborting."
        sys.exit(1)


def padFrameSize(framesize, size):
    return tuple([ceilMultiple(framesize[0], size),ceilMultiple(framesize[1], size)])


def getFrameSize(framesize, image):
    framesize = tuple(framesize)
    if not framesize < image.size:
        print "Frame is larger than image; exiting"
        sys.exit(1)
    return framesize


def requireFrameSize(framesize):
    if not framesize:
        print "Frame size required for",args.mode[0]+"; exiting"
        sys.exit(1)

    return framesize



args = getCommandLineArguments()
filenames = cleanFilenames(args.filenames)


if not filenames:
    print "No valid files selected"
else:
    for filename in filenames:


        im = openImage(filename)

        newfilename = filename+".dat"
        output_txt = open(newfilename,'w')


        if args.mode[0] == 'font':
            prefix = 'font_'
        else:
            prefix = 'gfx_'

        output_txt.write("%s%s\n" % (prefix,os.path.splitext(os.path.basename(filename))[0]))


        if args.mode[0] == 'sprite':

            if args.framesize:
                framesize = getFrameSize(args.framesize, im)
            else:
                framesize = im.size

            # Calculate frameboost constant, the precalculated frame size so 
            # that jumping to a frame requires only one multiplication, not three.
            frameboost = (framesize[0]*BITS_PER_PIXEL*framesize[1]/PIXELS_PER_ADDRESS) & 0xFFFF
            dimensions = (framesize[0] & 0xFFFF , framesize[1] & 0xFFFF) 

            output_txt.write("word    %i" % frameboost + "  'frameboost\n")
            output_txt.write("word    %i, %i   'width, height\n" % dimensions )

        elif args.mode[0] == 'box':
            framesize = im.size

        elif args.mode[0] == 'tilemap':
            framesize = DEFAULT_FRAME




        # Allow padding of tilized images for arbitrary font sizes
        if args.mode[0] == 'font':
            if args.framesize:
                framesize = getFrameSize(args.framesize, im)
            else:
                framesize = im.size

            output_framesize = tuple([ceilMultiple(framesize[0], TILESIZE),ceilMultiple(framesize[1], TILESIZE)])
            output_size = tuple([im.size[0]*output_framesize[0]/framesize[0],im.size[1]*output_framesize[1]/framesize[1]])


            print output_size

            framesize = requireFrameSize(args.framesize)
            output_im = Image.new("RGB",output_size)

            print output_framesize
        else:
            output_framesize = framesize
            output_im = Image.new("RGB",im.size)


        output_im.paste(TRANSPARENT_COLOR)

        if args.bits[0] == 2:
            if args.mode[0] == 'font':
                padFrameSize(framesize, TILESIZE)
            else:
                requirePower3FrameSize(framesize)



        count_tiles_x = im.size[0]/framesize[0]
        count_tiles_y = im.size[1]/framesize[1]


        # Iterate over image to splice into subdivisions
        for frame_y in range(0,count_tiles_y):
            for frame_x in range(0,count_tiles_x):

                for py in range(0,framesize[1]):
                    for px in range(0,framesize[0]):

                        x = frame_x*framesize[0] + px
                        y = frame_y*framesize[1] + py

                        out_x = frame_x*output_framesize[0] + px
                        out_y = frame_y*output_framesize[1] + py

                        pixeldata = im.getpixel((x,y))

                        if args.bits[0] == 2:

                            coloravg = getAverageColor(pixeldata)

                            if pixeldata == TRANSPARENT_COLOR:
                                output_im.putpixel((out_x,out_y), TRANSPARENT_COLOR)
                            elif coloravg < 40: # black
                                output_im.putpixel((out_x,out_y), (0,0,0))
                            elif 40 < coloravg < 210: # gray
                                output_im.putpixel((out_x,out_y), (128,128,128))
                            elif coloravg > 210: # white
                                output_im.putpixel((out_x,out_y), (255,255,255))

                        elif args.bits[0] == 8:
                            if type(pixeldata) is tuple:
                                r = pixeldata[0] >> 6 << 6
                                g = pixeldata[1] >> 6 << 6
                                b = pixeldata[2] >> 6 << 6
                                output_im.putpixel((x,y), (r, g, b))
                            else:
                                print "Color data not in tuple format?"
                                sys.exit(1)



        # Iterate again to render DAT output
        colordata = 0
        wordcount = 0
        output_count_tiles_x = output_im.size[0]/output_framesize[0]
        output_count_tiles_y = output_im.size[1]/output_framesize[1]

        
        for frame_y in range(0,output_count_tiles_y):
            for frame_x in range(0,output_count_tiles_x):

                for py in range(0,output_framesize[1]):
                    for px in range(0,output_framesize[0]):

                        x = frame_x*output_framesize[0] + px
                        y = frame_y*output_framesize[1] + py

                        if x % BITS_PER_BLOCK == 0:
                            colordata = 0

                        colorchar = 0
                        pixeldata = output_im.getpixel((x,y))

                        if args.bits[0] == 2:

                            coloravg = getAverageColor(pixeldata)

                            if pixeldata == TRANSPARENT_COLOR:
                                colorchar = 2
                            elif coloravg < 40: # black
                                output_im.putpixel((x,y), BLACK)
                                colorchar = 0
                            elif 40 < coloravg and coloravg < 210: # gray
                                output_im.putpixel((x,y), GRAY)
                                colorchar = 3
                            elif coloravg > 210: # white
                                output_im.putpixel((x,y), WHITE)
                                colorchar = 1

                            colordata += (colorchar << ((x % BITS_PER_BLOCK)*2))


                            if x % BITS_PER_BLOCK == BITS_PER_BLOCK-1 or x == output_im.size[0]-1:
                                output_txt.write("$"+hex(colordata)[2:].zfill(BITS_PER_BLOCK/2))

                            if x % BITS_PER_BLOCK == 0:
                                if wordcount % (BITS_PER_BLOCK*2) == 0:
                                    output_txt.write("\nword    ")
                                else:
                                    if x < output_im.size[0]-1:
                                        output_txt.write(", ")

                                wordcount += 1



                        elif args.bits[0] == 8:
                            if type(pixeldata) is tuple:
                                r = pixeldata[0] >> 6 << 6
                                g = pixeldata[1] >> 6 << 6
                                b = pixeldata[2] >> 6 << 6
                                colorchar = (r) + (g >> 2) + (b >> 4)
                            else:
                                print "Color data not in tuple format?"
                                sys.exit(1)



        

        output_txt.close()

        if args.display:
            canvas = Image.new("RGB",(output_im.size[0],im.size[1]+output_im.size[1]))
        
            canvas.paste(im,(0,0,im.size[0],im.size[1]))
            canvas.paste(output_im,(0,im.size[1]))
            
            canvas = canvas.resize(tupleMultiply(SCALEFACTOR,(output_im.size[0],im.size[1]+output_im.size[1])))
            canvas.show()


        printImageTag()
        printConversionResults(newfilename)
