#!/usr/bin/env python

import os, sys

from PIL import Image
import argparse

import files
import ImageData


SCALEFACTOR = 4

PIXELS_PER_ADDRESS = 8
BITS_PER_PIXEL = 2



DEFAULT_FRAME=(8,8)
TRANSPARENT_COLOR = (255,0,255)

TILESIZE = 8


def tupleMultiply(scalar,tup):
    return tuple([scalar*x for x in tup])

def ceilMultiple(x, multiple):
    if x % multiple == 0:
        return x
    else:
        return ((x/multiple)+1)*multiple

def getCommandLineArguments():
    parser = argparse.ArgumentParser(description='Convert images to Propeller Spin data blocks for use with Lame Graphics.')

    parser.add_argument('-m','--mode', nargs=1, metavar=('MODE'), choices=['box','sprite','font','tilemap'], default=['sprite'],
            help="""Indicates what the image is to be converted into:
                box - An image with a fixed 8x8 size, compatible with the box command.
                tilemap - A collection of boxes chopped from a tilemap image.
                sprite - An image of any width and height that may have multiple frames.
                font - Parse the image as a bitmap font.
            """)
    parser.add_argument('-b','--bits', nargs=1, metavar=('BITS'), type=int, choices=[2,8],default=[2],
            help="Bit depth of images.")
    parser.add_argument('-f','--framesize', nargs=2, metavar=('WIDTH','HEIGHT'), type=int,
            help="Size of individual sprite frames (only needed for sprites).")
    parser.add_argument('-d','--display', action='store_true',
            help="Show graphic comparison of old and new images.")

    parser.add_argument('filenames', metavar='FILE', nargs='+', help='Files to convert')
    return parser.parse_args()



def getAverageColor(pixel):
    if type(pixel) is tuple:
        return sum(pixel)/3
    else:
        return pixel


def requirePower3FrameSize(framesize):
    if not framesize[0] % 8 == 0:
        print "Error:",args.mode[0],"frame size x must be multiple of 8. Aborting."
        sys.exit(1)
    
    if not framesize[1] %8 == 0:
        print "Error:",args.mode[0],"frame size y must be multiple of 8. Aborting."
        sys.exit(1)


def padFrameSize(framesize, size):
    return tuple([ceilMultiple(framesize[0], size),ceilMultiple(framesize[1], size)])


def getFrameSize(framesize, image):
    framesize = tuple(framesize)
    if not framesize < image.size:
        print "Frame is larger than image; exiting"
        sys.exit(1)
    return framesize


def requireFrameSize(framesize):
    if not framesize:
        print "Frame size required for",args.mode[0]+"; exiting"
        sys.exit(1)

    return framesize

def getColorValue(pixeldata):
    coloravg = getAverageColor(pixeldata)

    if pixeldata == TRANSPARENT_COLOR:
        return 'none'
    elif coloravg < 40:
        return 'black'
    elif 40 < coloravg and coloravg < 210:
        return 'gray'
    elif coloravg > 210:
        return 'white'
    else:
        raise "Bad input data"

def displayResult(scale,oldimage, newimage):
    canvas = Image.new("RGB",(newimage.size[0],oldimage.size[1]+newimage.size[1]))

    canvas.paste(self.oldimage,(0,0,oldimage.size[0],oldimage.size[1]))
    canvas.paste(self.newimage,(0,oldimage.size[1]))
    
    canvas = canvas.resize(tuple([scale*x for x in (newimage.size[0],oldimage.size[1]+newimage.size[1])]))
    canvas.show()
        



args = getCommandLineArguments()
filenames = files.cleanFilenames(args.filenames)


if not filenames:
    print "No valid files selected"
    sys.exit(1)

for filename in filenames:

    imgdata = ImageData.ImageData()
    imgdata.openImage(filename)

    im = imgdata.getImage()

    if args.mode[0] == 'sprite' or args.mode[0] == 'font':
        if args.framesize:
            framesize = getFrameSize(args.framesize, im)
        else:
            framesize = im.size
    else:
        framesize = DEFAULT_FRAME

    # Allow padding of tilized images for arbitrary font sizes
    if args.mode[0] == 'font':
        output_framesize = padFrameSize(framesize, TILESIZE)
        output_size = tuple([im.size[0]*output_framesize[0]/framesize[0],im.size[1]*output_framesize[1]/framesize[1]])

        print output_size

        framesize = requireFrameSize(args.framesize)
        output_im = Image.new("RGB",output_size)

        print output_framesize
    else:
        output_framesize = framesize
        output_im = Image.new("RGB",im.size)
        requirePower3FrameSize(framesize)


    imgdata.setMode(args.mode[0])
    imgdata.setFrameSize(framesize)

    output_im.paste(TRANSPARENT_COLOR)

    count_tiles_x = im.size[0]/framesize[0]
    count_tiles_y = im.size[1]/framesize[1]


    # Iterate over image to splice into subdivisions
    for frame_y in range(0,count_tiles_y):
        for frame_x in range(0,count_tiles_x):

            for py in range(0,framesize[1]):

                for px in range(0,framesize[0]):

                    x = frame_x*framesize[0] + px
                    y = frame_y*framesize[1] + py

                    out_x = frame_x*output_framesize[0] + px
                    out_y = frame_y*output_framesize[1] + py

                    pixeldata = im.getpixel((x,y))

                    if args.bits[0] == 2:

                        coloravg = getAverageColor(pixeldata)

                        if pixeldata == TRANSPARENT_COLOR:
                            output_im.putpixel((out_x,out_y), TRANSPARENT_COLOR)
                        elif coloravg < 40: # black
                            output_im.putpixel((out_x,out_y), (0,0,0))
                        elif 40 < coloravg < 210: # gray
                            output_im.putpixel((out_x,out_y), (128,128,128))
                        elif coloravg > 210: # white
                            output_im.putpixel((out_x,out_y), (255,255,255))

                    elif args.bits[0] == 8:
                        if type(pixeldata) is tuple:
                            r = pixeldata[0] >> 6 << 6
                            g = pixeldata[1] >> 6 << 6
                            b = pixeldata[2] >> 6 << 6
                            output_im.putpixel((x,y), (r, g, b))
                        else:
                            print "Color data not in tuple format?"
                            sys.exit(1)



    # Iterate again to render DAT output
    output_count_tiles_x = output_im.size[0]/output_framesize[0]
    output_count_tiles_y = output_im.size[1]/output_framesize[1]

    frame = 0
    
    spritedata = []

    for frame_y in range(0,output_count_tiles_y):
        for frame_x in range(0,output_count_tiles_x):

            imagedata = []

            for py in range(0,output_framesize[1]):

                linedata = []

                for px in range(0,output_framesize[0]):

                    x = frame_x*output_framesize[0] + px
                    y = frame_y*output_framesize[1] + py

                    colorchar = 0
                    pixeldata = output_im.getpixel((x,y))

                    if args.bits[0] == 2:
                        color = getColorValue(pixeldata)
                        linedata.append(color)

                        output_im.putpixel((x,y),ImageData.colorvalue[color]['output'])

                    elif args.bits[0] == 8:
                        if type(pixeldata) is tuple:
                            r = pixeldata[0] >> 6 << 6
                            g = pixeldata[1] >> 6 << 6
                            b = pixeldata[2] >> 6 << 6
                            colorchar = (r) + (g >> 2) + (b >> 4)
                        else:
                            print "Color data not in tuple format?"
                            sys.exit(1)


                imagedata.append(linedata)
            spritedata.append(imagedata)
            frame += 1

    if args.display:
        imgdata.setNewImage(output_im)
        displayResult(4)
        

    spin = imgdata.assembleSpinFile(spritedata)
    print spin

    imgdata.writeSpinFile(spin)
    imgdata.printImageTag()
