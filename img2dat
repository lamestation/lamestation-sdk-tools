#!/usr/bin/env python

import os, sys

from PIL import Image
import argparse


LS_SCREEN_W = 128
LS_SCREEN_H = 64

SCALEFACTOR = 4

PAGES = 8
ADDRESSES = 128
PIXELS_PER_ADDRESS = 8
BITS_PER_PIXEL = 2

BITS_PER_BLOCK = 8

def multiply_tuple(scalar,tup):
    return tuple([scalar*x for x in tup])


parser = argparse.ArgumentParser(description='Convert images to Propeller Spin data blocks for use with Lame Graphics.')

parser.add_argument('-m','--mode', nargs=1, metavar=('MODE'), choices=['sprite','font','block'], default=['sprite'],
        help="""Indicates what the image is to be converted into:
            block - Image with no header, often used for tilemaps
            sprite - An image with custom width/height and that may have multiple frames
            font - A bitmap font to be used with lame_text
        """)
parser.add_argument('-b','--bits', nargs=1, metavar=('BITS'), type=int, choices=[2,8],default=[2],
        help="Bit depth of images.")

parser.add_argument('-f','--framesize', nargs=2, metavar=('WIDTH','HEIGHT'), type=int,
        help="Size of individual sprite frames (only needed for sprites).")

parser.add_argument('-d','--display', action='store_true',
        help="Show graphic comparison of old and new images.")

parser.add_argument('filenames', metavar='FILE', nargs='+', help='Files to convert')


args = parser.parse_args()

filenames = [ i for i in args.filenames if not os.path.splitext(i)[1] == '.dat' and os.path.isfile(i) ]
filenames = [ i for i in filenames if not os.path.splitext(i)[1] == '.txt' ]

if not filenames:
    print "No valid files selected"
else:
    for filename in filenames:
        newfilename = filename+".dat"

        try:
            im = Image.open(filename)
        except IOError:
            print filename, "is not a valid image file"
            sys.exit(1)

        im = im.convert("RGB")
        output_im = Image.new("RGB",im.size)
        output_txt = open(newfilename,'w')

        output_txt.write("gfx_%s\n" % os.path.splitext(os.path.basename(filename))[0])


        if args.mode[0] == 'sprite':

            # Check if framesize passed in arguments
            if args.framesize:
                framesize = tuple(args.framesize)
                if not framesize < im.size:
                    print "Frame is larger than image; exiting"
                    sys.exit(1)
            else:
                framesize = im.size


            # Calculate frameboost constant, the precalculated frame size so 
            # that jumping to a frame requires only one multiplication, not three.
            frameboost = (framesize[0]*BITS_PER_PIXEL*framesize[1]/PIXELS_PER_ADDRESS) & 0xFFFF
            dimensions = (framesize[0] & 0xFFFF , framesize[1] & 0xFFFF) 

            output_txt.write("word    %i" % frameboost + "  'frameboost\n")
            output_txt.write("word    %i, %i   'width, height\n" % dimensions )

        elif args.mode[0] == 'block':
            framesize = im.size



        wordcount = 0
        colordata = 0

        for y in range(0,im.size[1]):
            for x in range(0,im.size[0]):

                if x % BITS_PER_BLOCK == 0:
                    colordata = 0

                colorchar = 0
                pixeldata = im.getpixel((x,y))

                if args.bits[0] == 2:
                    if type(pixeldata) is tuple:
                        coloravg = sum(pixeldata)/3

                    else:
                        coloravg = pixeldata
# BLACK = 0
# WHITE = 1
# TRANSPARENT = 2
# GRAY = 3

                    # Pink is the alpha color
                    if pixeldata == (255,0,255):
                        output_im.putpixel((x,y), (255, 0, 255))
                        colorchar = 2
                    else:
                        # if color is not black
                        if coloravg > 40:

                            # if not white, gray
                            if coloravg < 210:
                                output_im.putpixel((x,y), (139, 138, 116))
                                colorchar = 3
                            else:
                                output_im.putpixel((x,y), (255, 233, 166))
                                colorchar = 1

                        else:
                            ## if black
                            output_im.putpixel((x,y), (23,43,66))
                            colorchar = 0

                    colordata += (colorchar << ((x % BITS_PER_BLOCK)*2))


                    if x % BITS_PER_BLOCK == BITS_PER_BLOCK-1 or x == im.size[0]-1:
                        output_txt.write("$"+hex(colordata)[2:].zfill(BITS_PER_BLOCK/2))

                    if x % BITS_PER_BLOCK == 0:
                        if wordcount % (BITS_PER_BLOCK*2) == 0:
                            output_txt.write("\nword    ")
                        else:
                            if x < im.size[0]-1:
                                output_txt.write(", ")

                        wordcount += 1







                elif args.bits[0] == 8:
                    if type(pixeldata) is tuple:
                        r = pixeldata[0] >> 6 << 6
                        g = pixeldata[1] >> 6 << 6
                        b = pixeldata[2] >> 6 << 6
                        output_im.putpixel((x,y), (r, g, b))
                        colorchar = (r) + (g >> 2) + (b >> 4)
                    else:
                        print "Color data not in tuple format?"
                        sys.exit(1)

        output_txt.close()

        if args.display:
            # Create a canvas to paste both the input and output images onto
            output_canvas = Image.new("RGB",(im.size[0],im.size[1]*2))
            output_canvas.paste(im,(0,0))
            output_canvas.paste(output_im,(0,im.size[1]))

            # Then resize the canvas to make it easier to see
            output_canvas = output_canvas.resize(multiply_tuple(SCALEFACTOR,(im.size[0],im.size[1]*2)))
            output_canvas.show()

        print "'   Creating:",newfilename
        print "'  Bit depth:", args.bits[0]
        print "' Image Type:", args.mode[0]
        print "' Image size:",im.size
        print "' Frame size:",framesize
        print "'------------------- COPY AFTER THIS LINE --------------------"

        print open(newfilename,'r').read()
