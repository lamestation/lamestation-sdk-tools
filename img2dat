#!/usr/bin/env python

import os, sys

from PIL import Image
import argparse

colorvalue = {}
colorvalue = {'white':{}}
colorvalue = {'black':{}}
colorvalue = {'gray':{}}
colorvalue = {'none':{}}

colorvalue['white']= {'unicode': u"\u2591", 'char': 1, 'output': (204,206,203)}
colorvalue['gray'] = {'unicode': u"\u2593", 'char': 3, 'output': (177,125,225)}
colorvalue['black']= {'unicode': u"\u2588", 'char': 0, 'output': (145,64,254)}
colorvalue['none'] = {'unicode': u" ", 'char': 2, 'output': (255,0,255)}



SCALEFACTOR = 4

PIXELS_PER_ADDRESS = 8
BITS_PER_PIXEL = 2

BITS_PER_BLOCK = 8


DEFAULT_FRAME=(8,8)
TRANSPARENT_COLOR = (255,0,255)

TILESIZE = 8


# Basic functions
def tupleMultiply(scalar,tup):
    return tuple([scalar*x for x in tup])

def ceilMultiple(x, multiple):
    if x % multiple == 0:
        return x
    else:
        return ((x/multiple)+1)*multiple

def getCommandLineArguments():
    parser = argparse.ArgumentParser(description='Convert images to Propeller Spin data blocks for use with Lame Graphics.')

    parser.add_argument('-m','--mode', nargs=1, metavar=('MODE'), choices=['box','sprite','font','tilemap'], default=['sprite'],
            help="""Indicates what the image is to be converted into:
                box - An image with a fixed 8x8 size, compatible with the box command.
                tilemap - A collection of boxes chopped from a tilemap image.
                sprite - An image of any width and height that may have multiple frames.
                font - Parse the image as a bitmap font.
            """)
    parser.add_argument('-b','--bits', nargs=1, metavar=('BITS'), type=int, choices=[2,8],default=[2],
            help="Bit depth of images.")
    parser.add_argument('-f','--framesize', nargs=2, metavar=('WIDTH','HEIGHT'), type=int,
            help="Size of individual sprite frames (only needed for sprites).")
    parser.add_argument('-d','--display', action='store_true',
            help="Show graphic comparison of old and new images.")

    parser.add_argument('filenames', metavar='FILE', nargs='+', help='Files to convert')
    return parser.parse_args()

def printImageTag():
    print "'   Creating:",newfilename
    print "'  Bit depth:", args.bits[0]
    print "' Image Type:", args.mode[0]
    print "' Image size:",im.size
    print "' Frame size:",framesize
    print "'     Frames:",count_tiles_x,",",count_tiles_x


def cleanFilenames(filenames):
    filenames = [ i for i in filenames if not os.path.splitext(i)[1] == '.dat' and os.path.isfile(i) ]
    filenames = [ i for i in filenames if not os.path.splitext(i)[1] == '.txt' ]
    return filenames


def openImage(filename):
    try:
        im = Image.open(filename)
    except IOError:
        print filename, "is not a valid image file"
        sys.exit(1)
    
    return im.convert("RGB")

def getAverageColor(pixel):
    if type(pixel) is tuple:
        return sum(pixel)/3
    else:
        return pixel


def requirePower3FrameSize(framesize):
    if not framesize[0] % 8 == 0:
        print "Error:",args.mode[0],"frame size x must be multiple of 8. Aborting."
        sys.exit(1)
    
    if not framesize[1] %8 == 0:
        print "Error:",args.mode[0],"frame size y must be multiple of 8. Aborting."
        sys.exit(1)


def padFrameSize(framesize, size):
    return tuple([ceilMultiple(framesize[0], size),ceilMultiple(framesize[1], size)])


def getFrameSize(framesize, image):
    framesize = tuple(framesize)
    if not framesize < image.size:
        print "Frame is larger than image; exiting"
        sys.exit(1)
    return framesize


def requireFrameSize(framesize):
    if not framesize:
        print "Frame size required for",args.mode[0]+"; exiting"
        sys.exit(1)

    return framesize

def getColorValue(pixeldata):
    coloravg = getAverageColor(pixeldata)

    if pixeldata == TRANSPARENT_COLOR:
        return 'none'
    elif coloravg < 40:
        return 'black'
    elif 40 < coloravg and coloravg < 210:
        return 'gray'
    elif coloravg > 210:
        return 'white'
    else:
        raise "Bad input data"



def lineRule():
    return "' *********************************************************\n"

def assembleSpinHeader(image):
    output = ""
    output += lineRule()
    output += "' "+str(prefix)+os.path.splitext(os.path.basename(filename))[0]+".spin\n"
    output += "' Graphics generated by img2dat\n"
    output += lineRule()

    output += "PUB Addr\n"
    output += "    return @gfx_data\n\n"
    output += "DAT\n\n"
    output += "gfx_data"
    return output

def assembleWordHeader(image):
    output = ""
    output += "word    "+str(frameboost)+" ' frameboost\n"
    output += "word    "+str(len(image[0]))+", "+str(len(image))+" ' width, height"
    return output



def assembleLine(line, radix):
    output = ""
    colordata = 0

    for x in range(0,len(line)):

        if radix == 'hex':
            if x % BITS_PER_BLOCK == 0:
                colordata = 0

            colordata += (colorvalue[line[x]]['char'] << ((x % BITS_PER_BLOCK)*2))

            if x % BITS_PER_BLOCK == 7:
                output += "$"+hex(colordata)[2:].zfill(BITS_PER_BLOCK/2)
                if x < (len(line)-1):
                    output += ","

        elif radix == 'quaternary':

            if x % BITS_PER_BLOCK == 0:
                output += "%%"

            xindex = (x/BITS_PER_BLOCK)*BITS_PER_BLOCK + BITS_PER_BLOCK-1 - x % BITS_PER_BLOCK
            output += str(colorvalue[line[xindex]]['char'])

            if x % BITS_PER_BLOCK == 7:
                if x < (len(line)-1):
                    output += ","

        elif radix == 'unicode':
            output += colorvalue[line[x]]['unicode'].encode('utf-8')
    return output


def assembleData(image, radix):
    output = ""

    for y in range(0,len(image)):
        if radix == 'both':
            output += "\nword    "
            output += assembleLine(image[y], 'hex')
            output += " ' "
            output += assembleLine(image[y], 'unicode')
        else:
            if radix == 'unicode':
                output += "\n' "
            else:
                output += "\nword    "
            output += assembleLine(image[y], radix)


    return output


args = getCommandLineArguments()
filenames = cleanFilenames(args.filenames)


if not filenames:
    print "No valid files selected"
else:
    for filename in filenames:

        im = openImage(filename)

        newfilename = filename+".dat"


        if args.mode[0] == 'font':
            prefix = 'font_'
        else:
            prefix = 'gfx_'



        if args.mode[0] == 'sprite':

            if args.framesize:
                framesize = getFrameSize(args.framesize, im)
            else:
                framesize = im.size

            # Calculate frameboost constant, the precalculated frame size so 
            # that jumping to a frame requires only one multiplication, not three.
            frameboost = (framesize[0]*BITS_PER_PIXEL*framesize[1]/PIXELS_PER_ADDRESS) & 0xFFFF
            dimensions = (framesize[0] & 0xFFFF , framesize[1] & 0xFFFF) 

        elif args.mode[0] == 'box':
            framesize = im.size

        elif args.mode[0] == 'tilemap':
            framesize = DEFAULT_FRAME




        # Allow padding of tilized images for arbitrary font sizes
        if args.mode[0] == 'font':
            if args.framesize:
                framesize = getFrameSize(args.framesize, im)
            else:
                framesize = im.size

            output_framesize = tuple([ceilMultiple(framesize[0], TILESIZE),ceilMultiple(framesize[1], TILESIZE)])
            output_size = tuple([im.size[0]*output_framesize[0]/framesize[0],im.size[1]*output_framesize[1]/framesize[1]])


            print output_size

            framesize = requireFrameSize(args.framesize)
            output_im = Image.new("RGB",output_size)

            print output_framesize
        else:
            output_framesize = framesize
            output_im = Image.new("RGB",im.size)


        output_im.paste(TRANSPARENT_COLOR)

        if args.bits[0] == 2:
            if args.mode[0] == 'font':
                padFrameSize(framesize, TILESIZE)
            else:
                requirePower3FrameSize(framesize)



        count_tiles_x = im.size[0]/framesize[0]
        count_tiles_y = im.size[1]/framesize[1]


        # Iterate over image to splice into subdivisions
        for frame_y in range(0,count_tiles_y):
            for frame_x in range(0,count_tiles_x):

                for py in range(0,framesize[1]):

                    for px in range(0,framesize[0]):

                        x = frame_x*framesize[0] + px
                        y = frame_y*framesize[1] + py

                        out_x = frame_x*output_framesize[0] + px
                        out_y = frame_y*output_framesize[1] + py

                        pixeldata = im.getpixel((x,y))

                        if args.bits[0] == 2:

                            coloravg = getAverageColor(pixeldata)

                            if pixeldata == TRANSPARENT_COLOR:
                                output_im.putpixel((out_x,out_y), TRANSPARENT_COLOR)
                            elif coloravg < 40: # black
                                output_im.putpixel((out_x,out_y), (0,0,0))
                            elif 40 < coloravg < 210: # gray
                                output_im.putpixel((out_x,out_y), (128,128,128))
                            elif coloravg > 210: # white
                                output_im.putpixel((out_x,out_y), (255,255,255))

                        elif args.bits[0] == 8:
                            if type(pixeldata) is tuple:
                                r = pixeldata[0] >> 6 << 6
                                g = pixeldata[1] >> 6 << 6
                                b = pixeldata[2] >> 6 << 6
                                output_im.putpixel((x,y), (r, g, b))
                            else:
                                print "Color data not in tuple format?"
                                sys.exit(1)



        # Iterate again to render DAT output
        output_count_tiles_x = output_im.size[0]/output_framesize[0]
        output_count_tiles_y = output_im.size[1]/output_framesize[1]

        frame = 0
        
        spritedata = []

        for frame_y in range(0,output_count_tiles_y):
            for frame_x in range(0,output_count_tiles_x):

                imagedata = []

                for py in range(0,output_framesize[1]):

                    linedata = []

                    for px in range(0,output_framesize[0]):

                        x = frame_x*output_framesize[0] + px
                        y = frame_y*output_framesize[1] + py

                        colorchar = 0
                        pixeldata = output_im.getpixel((x,y))

                        if args.bits[0] == 2:
                            color = getColorValue(pixeldata)
                            linedata.append(color)

                            output_im.putpixel((x,y),colorvalue[color]['output'])

                        elif args.bits[0] == 8:
                            if type(pixeldata) is tuple:
                                r = pixeldata[0] >> 6 << 6
                                g = pixeldata[1] >> 6 << 6
                                b = pixeldata[2] >> 6 << 6
                                colorchar = (r) + (g >> 2) + (b >> 4)
                            else:
                                print "Color data not in tuple format?"
                                sys.exit(1)


                    imagedata.append(linedata)
                spritedata.append(imagedata)
                frame += 1

        if args.display:
            canvas = Image.new("RGB",(output_im.size[0],im.size[1]+output_im.size[1]))
        
            canvas.paste(im,(0,0,im.size[0],im.size[1]))
            canvas.paste(output_im,(0,im.size[1]))
            
            canvas = canvas.resize(tupleMultiply(SCALEFACTOR,(output_im.size[0],im.size[1]+output_im.size[1])))
            canvas.show()

        print assembleSpinHeader(imagedata)
        if args.mode[0] == 'sprite':
            print assembleWordHeader(imagedata)

        for s in spritedata:
            print assembleData(s,'both')


        #printImageTag()
