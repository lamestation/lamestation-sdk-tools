#!/usr/bin/env python

import sys, os, re
import xml.etree.ElementTree as ET
import base64
import argparse

import subprocess

from PIL import Image


parser = argparse.ArgumentParser(description="""\
        Convert tmx maps to data blocks for in-game tiled maps

        Currently, CSV maps are supported.

        This tool will create pack files that will contain compatible
        map and tile data in a single file.
        """)
parser.add_argument('filenames', metavar='FILE', nargs='+', help='Maps to convert')

args = parser.parse_args()

filenames = [ i for i in args.filenames if os.path.splitext(i)[1] == '.tmx' and os.path.isfile(i) ]

oldtilemap_name = ""
mapsets = {}


if not filenames:
    print "No valid file paths given."
    sys.exit(1)
else:
    for filename in args.filenames:
        tree = ET.parse(filename)

        root = tree.getroot()

        width = int(root.attrib['width'])
        height = int(root.attrib['height'])

        newfilename = filename+'.dat'
        f = open(newfilename,'w')

        reference_name = "map_" + os.path.splitext(os.path.basename(filename))[0]
        f.write("\n%s\n" % reference_name)
        f.write("byte\t%3i, %3i  'width, height\n" % (width, height))

        tileset = root.find(".//tileset[@firstgid='1']")
        tilemap_name = tileset.find('image').attrib['source']
        tilemap_w = int(tileset.find('image').attrib['width'])
        tilemap_tilew = int(tileset.attrib['tilewidth'])
        tilemap_tileh = int(tileset.attrib['tilewidth'])
        tilemap_inc = tilemap_w/tilemap_tilew

        fullpath_tilemap_name = os.path.join(os.path.dirname(newfilename),tilemap_name)
        newtilemap_name = fullpath_tilemap_name+'.dat'

        ## See if a corresponding collision map is available
        collisionmap_name = fullpath_tilemap_name.split('.')[0]+'_collision.'+fullpath_tilemap_name.split('.')[1]

        if not oldtilemap_name == tilemap_name:
            mapsets[newtilemap_name] = {}
            subprocess.call([os.path.join(os.path.dirname(__file__),"img2dat"), "--mode","block",fullpath_tilemap_name])
            oldtilemap_name = tilemap_name
            
        mapinfo = {"reference": reference_name, "width": width, "height": height}
        mapsets[newtilemap_name][newfilename] = mapinfo

        leveldata = {}

        for child in root.iter('layer'):
            maplayer = child.attrib['name']
            data = child.find('data')
            if data.attrib['encoding'] == 'csv':

                text = re.sub(r"[\r\n]","", data.text)
                text = text.split(',')
                n = len(text)

                leveldata[child.attrib['name']] = text
            else:
                print "Unsupported encoding scheme; exiting!"
                sys.exit(1)

        def layer_with_collision(leveldatavalue,j):
            value = int(leveldatavalue[maplayer][j])

            tilex = value % tilemap_inc - 1
            tiley = value / tilemap_inc

            if not sum(collision_data.getpixel((tilex*tilemap_tilew,tiley*tilemap_tileh)))/3 > 0:
                value += 1 << 7
            return value

        def layer_no_collision(leveldatavalue,j):
            return int(leveldatavalue[maplayer][j])


        def process_output(process_stage):
            for i in range(0,len(text)):
                if i % width == 0:
                    f.write("byte\t")

                f.write("%3i" % process_stage(leveldata,i))

                if i % width != width-1:
                    f.write(",")
                else:
                    f.write("\n")

        try:
            #leveldata['Collision']
            collision_data = Image.open(collisionmap_name).convert("RGB")
        except KeyError:
#            print "No collision layer"
            process_output(layer_no_collision)
        else:
#            print "Collision layer found"
            process_output(layer_with_collision)

        
        object_data = root.find(".//objectgroup[@name='start']")
        if object_data:
            if not object_data == []:
                f.write("\n' startlocations\n")

                f.write("\nbyte\t%i" % len(object_data))

                for o in object_data:
                    f.write("\nbyte\t"+str(int(o.attrib['x'])/tilemap_tilew)+", "
                            +str(int(o.attrib['y'])/tilemap_tilew))


        f.close()


for tilemap in mapsets:
    packfile = tilemap+".pack"
    f = open(packfile,'w')

    f.write("\nmapTable_%s\nword\t@" % os.path.basename(tilemap.split('.')[0]))

    flist = []
    for level in mapsets[tilemap]:
        flist.append(mapsets[tilemap][level]['reference'])

    f.write(", @".join(flist))
    f.write("\n\n")

    f.write(open(tilemap).read())

    for level in mapsets[tilemap]:
        f.write(open(level).read())
    f.close()

    print open(packfile,'r').read()
