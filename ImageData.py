import os, sys
from PIL import Image



colorvalue = {}
colorvalue = {'white':{}}
colorvalue = {'black':{}}
colorvalue = {'gray':{}}
colorvalue = {'none':{}}

colorvalue['white']= {'unicode': u"\u2591", 'char': 1, 'output': (204,206,203)}
colorvalue['gray'] = {'unicode': u"\u2593", 'char': 3, 'output': (177,125,225)}
colorvalue['black']= {'unicode': u"\u2588", 'char': 0, 'output': (145,64,254)}
colorvalue['none'] = {'unicode': u" ", 'char': 2, 'output': (255,0,255)}




SCALEFACTOR = 4

PIXELS_PER_ADDRESS = 8
BITS_PER_PIXEL = 2

BITS_PER_BLOCK = 8


DEFAULT_FRAME=(8,8)
TRANSPARENT_COLOR = (255,0,255)

TILESIZE = 8

def ceilMultiple(x, multiple):
    if x % multiple == 0:
        return x
    else:
        return ((x/multiple)+1)*multiple

class ImageData:

    prefix = 'gfx_'
    mode = 'sprite'

    spin = ''

    def __init__(self,filename,mode):
        self.spritedata = []
        self.framecount_x = 0
        self.framecount_y = 0
        self.frameboost = 0
        self.framesize = (8,8)

        self.filename = filename
        self.loadImage(filename)

        self.setMode(mode)
        self.setPrefix()

    def getOutputFramesize(self):
        return self.output_framesize

    def setMode(self,mode):
        self.mode = mode

    def setPrefix(self):
        if self.mode == 'font':
            self.prefix = 'font_'
        elif self.mode == 'tilemap':
            self.prefix = 'tilemap_'
        else:
            self.prefix = 'gfx_'


    def loadImage(self,filename):
        try:
            self.im = Image.open(self.filename)
        except IOError:
            print self.filename, "is not a valid image file"
            sys.exit(1)
        
        self.im = self.im.convert("RGB")

    def getImage(self):
        return self.im

    def setFrameSize(self,framesize):
        self.framesize = framesize

        if self.mode == 'sprite' or self.mode == 'font':
            if self.framesize:
                self.getFrameSize()
            else:
                self.framesize = self.im.size

        if self.mode == 'box' or self.mode == 'tilemap':
            self.framesize = DEFAULT_FRAME

        self.calculateFrameboost()

        return self.framesize

    def getFrameSize(self):
        self.framesize = tuple(self.framesize)
        if not self.framesize < self.im.size:
            print "Frame is larger than image; exiting"
            sys.exit(1)

    def padFrameSize(self, framesize, size):
        return tuple([ceilMultiple(framesize[0], size),ceilMultiple(framesize[1], size)])

    def requirePower3FrameSize(self):
        if not self.framesize[0] % 8 == 0:
            print "Error:",self.mode,"frame size x must be multiple of 8. Aborting."
            sys.exit(1)
        
        if not self.framesize[1] % 8 == 0:
            print "Error:",self.mode,"frame size y must be multiple of 8. Aborting."
            sys.exit(1)


    def calculateFrameboost(self):
        """Calculate frameboost constant, the precalculated frame size so 
        that jumping to a frame requires only one multiplication, not three."""
        self.frameboost = (self.framesize[0]*BITS_PER_PIXEL*self.framesize[1]/PIXELS_PER_ADDRESS) & 0xFFFF

    def countFrames(self):
        self.framecount_x = self.im.size[0]/self.framesize[0]
        self.framecount_y = self.im.size[1]/self.framesize[1]

    def setFramePadding(self):
        # Allow padding of tilized images for arbitrary font sizes
        if self.mode == 'font':
            self.output_framesize = self.padFrameSize(self.framesize, TILESIZE)
        else:
            self.output_framesize = self.framesize
            self.requirePower3FrameSize()


        self.countFrames()
        self.calculateFrameboost()


    def getPaddedCanvas(self,image,framesize):
        new_framesize = self.padFrameSize(framesize, TILESIZE)
        return Image.new("RGB",tuple([image.size[0]*new_framesize[0]/framesize[0],image.size[1]*new_framesize[1]/framesize[1]]))


    #def buildImageData(self):



    def lineRule(self):
        return "' *********************************************************\n"
    
    def assembleSpinHeader(self):
        output = ""
        output += self.lineRule()
        output += "' "+str(self.prefix)+os.path.splitext(os.path.basename(self.filename))[0]+".spin\n"
        output += "' Graphics generated by img2dat\n"
        output += self.lineRule()
    
        output += "PUB Addr\n"
        output += "    return @gfx_data\n\n"
        output += "DAT\n\n"
        output += "gfx_data"
        return output
    
    def assembleWordHeader(self,image):
        output = ""
        output += "word    "+str(self.frameboost)+" ' frameboost\n"
        output += "word    "+str(len(image[0]))+", "+str(len(image))+" ' width, height\n"
        return output
    
    
    def assembleLine(self, line, radix):
        output = ""
        colordata = 0
    
        for x in range(0,len(line)):
    
            if radix == 'hex':
                if x % BITS_PER_BLOCK == 0:
                    colordata = 0
    
                colordata += (colorvalue[line[x]]['char'] << ((x % BITS_PER_BLOCK)*2))
    
                if x % BITS_PER_BLOCK == 7:
                    output += "$"+hex(colordata)[2:].zfill(BITS_PER_BLOCK/2)
                    if x < (len(line)-1):
                        output += ","
    
            elif radix == 'quaternary':
    
                if x % BITS_PER_BLOCK == 0:
                    output += "%%"
    
                xindex = (x/BITS_PER_BLOCK)*BITS_PER_BLOCK + BITS_PER_BLOCK-1 - x % BITS_PER_BLOCK
                output += str(colorvalue[line[xindex]]['char'])
    
                if x % BITS_PER_BLOCK == 7:
                    if x < (len(line)-1):
                        output += ","
    
            elif radix == 'unicode':
                output += colorvalue[line[x]]['unicode'].encode('utf-8')
        return output
    
    
    def assembleData(self, image, radix):
        output = ""
    
        for y in range(0,len(image)):
            if radix == 'both':
                output += "\nword    "
                output += self.assembleLine(image[y], 'hex')
                output += " ' "
                output += self.assembleLine(image[y], 'unicode')
            else:
                if radix == 'unicode':
                    output += "\n' "
                else:
                    output += "\nword    "
                output += self.assembleLine(image[y], radix)
    
    
        return output
    
    def assembleSpinFile(self, sprite):
        imagedata = sprite[0]
        output = ""
        output += self.assembleSpinHeader()
        output += "\n"
    
        if self.mode == 'sprite':
            output += "\n"
            output += self.assembleWordHeader(sprite[0])
    
        frame = 0
        for s in sprite:
            output += "' frame "+str(frame)
            output += self.assembleData(s,'both')
            output += "\n"
            frame += 1
        output += "\n"
    
        self.spin = output
        return output

    def printSpinFile(self):
        print self.spin

    def writeSpinFile(self):
        f = open(self.getFullFilename(self.prefix, self.filename, "spin"),"w")
        f.write(self.spin)
        f.close()

    
